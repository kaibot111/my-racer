<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Retro Racer Online (Server Authoritative)</title>
    <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a1a; color: white; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        #hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }
        .stat-box { background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.2); }
        
        .no-js-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; background: rgba(255,0,0,0.2); padding: 40px; border: 2px solid red; border-radius: 10px;
        }

        #mobile-controls {
            display: none; position: absolute; bottom: 20px; width: 100%; height: 150px; pointer-events: auto;
        }
        .control-btn {
            position: absolute; width: 80px; height: 80px;
            background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%; pointer-events: auto; touch-action: manipulation;
        }
        .control-btn:active { background: rgba(255,255,255,0.4); }
        #btn-left { left: 20px; bottom: 20px; }
        #btn-right { left: 120px; bottom: 20px; }
        #btn-gas { right: 20px; bottom: 20px; background: rgba(0, 230, 118, 0.3); }
        #btn-brake { right: 120px; bottom: 20px; background: rgba(255, 23, 68, 0.3); width: 60px; height: 60px; bottom: 30px;}

        @media (max-width: 768px) { #mobile-controls { display: block; } }
    </style>
</head>
<body>

<noscript><div class="no-js-message"><h1>⚠️ Javascript Required</h1></div></noscript>
<div id="canvas-container"></div>

<div id="ui-layer">
    <div id="hud">
        <div class="stat-box">Ping: <span id="ping-display">0</span>ms</div>
        <div class="stat-box">PLAYERS: <span id="player-count-display">0</span></div>
    </div>
    <div id="mobile-controls">
        <div id="btn-left" class="control-btn" data-key="ArrowLeft"></div>
        <div id="btn-right" class="control-btn" data-key="ArrowRight"></div>
        <div id="btn-brake" class="control-btn" data-key="ArrowDown"></div>
        <div id="btn-gas" class="control-btn" data-key="ArrowUp"></div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    let socket;
    let myId = null;
    let playersMesh = {}; // Stores the 3D objects
    
    // Inputs
    const inputs = { up: false, down: false, left: false, right: false };
    
    // --- CONNECT ---
    try {
        if (typeof io !== 'undefined') {
            socket = io();
            
            // 1. Initial Setup
            socket.on('init', (data) => {
                myId = data.id;
                // Create existing players
                for(let id in data.players) {
                    if(!playersMesh[id]) createCarMesh(id, data.players[id].color);
                }
            });

            // 2. The Main Update Loop (Received from Server)
            socket.on('stateUpdate', (serverPlayers) => {
                const count = Object.keys(serverPlayers).length;
                document.getElementById('player-count-display').innerText = count;

                for (let id in serverPlayers) {
                    const pState = serverPlayers[id];

                    // If we see a player ID we don't have a mesh for, create it
                    if (!playersMesh[id]) {
                        createCarMesh(id, pState.color);
                    }

                    // Update Position strictly based on server data
                    const mesh = playersMesh[id];
                    mesh.position.set(pState.x, 0, pState.z);
                    mesh.rotation.y = pState.angle;

                    // If this is ME, update the camera
                    if (id === myId) {
                        updateCamera(mesh);
                    }
                }
            });

            socket.on('playerDisconnected', (id) => {
                if (playersMesh[id]) {
                    scene.remove(playersMesh[id]);
                    delete playersMesh[id];
                }
            });

            // Ping Check
            setInterval(() => {
                const start = Date.now();
                socket.emit('ping', () => {
                    document.getElementById('ping-display').innerText = Date.now() - start;
                });
            }, 2000);

        }
    } catch(e) { console.error(e); }

    // --- THREE JS SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 100, 50);
    dirLight.castShadow = true;
    const d = 150;
    dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
    dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
    dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    // --- ASSETS ---
    function createCarMesh(id, color) {
        const carGroup = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1, 0.5, 2.2), new THREE.MeshStandardMaterial({ color: color || 0xff0000 }));
        body.position.y = 0.5; body.castShadow = true; carGroup.add(body);
        
        const cabin = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 1), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        cabin.position.set(0, 0.9, -0.2); carGroup.add(cabin);
        
        const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 24);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        [{ x: 0.6, z: 0.8 }, { x: -0.6, z: 0.8 }, { x: 0.6, z: -0.8 }, { x: -0.6, z: -0.8 }].forEach(p => {
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.rotation.z = Math.PI / 2; w.position.set(p.x, 0.35, p.z); carGroup.add(w);
        });

        scene.add(carGroup);
        playersMesh[id] = carGroup;
        return carGroup;
    }

    function createTrack() {
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshStandardMaterial({ color: 0x388E3C }));
        ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; scene.add(ground);
        
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x424242 });
        const trackWidth = 14;
        
        function addRoad(x, z, w, l, rotY) {
            const r = new THREE.Mesh(new THREE.PlaneGeometry(w, l), roadMat);
            r.rotation.x = -Math.PI/2; r.rotation.z = rotY; r.position.set(x, 0.02, z); r.receiveShadow = true;
            scene.add(r);
        }
        addRoad(0, -50, trackWidth, 110, 0); 
        addRoad(50, -100, trackWidth, 110, Math.PI / 2);
        addRoad(100, -50, trackWidth, 110, 0); 
        addRoad(50, 0, trackWidth, 110, Math.PI / 2);
    }
    createTrack();

    // --- INPUT HANDLING ---
    // Instead of moving the car, we just tell the server "I am pressing UP"
    function sendInput() {
        if (socket) socket.emit('input', inputs);
    }

    const keyMap = { ArrowUp: 'up', w: 'up', ArrowDown: 'down', s: 'down', ArrowLeft: 'left', a: 'left', ArrowRight: 'right', d: 'right' };

    window.addEventListener('keydown', (e) => {
        const k = e.key.length === 1 ? e.key.toLowerCase() : e.key;
        if(keyMap[k]) {
            inputs[keyMap[k]] = true;
            sendInput();
        }
    });

    window.addEventListener('keyup', (e) => {
        const k = e.key.length === 1 ? e.key.toLowerCase() : e.key;
        if(keyMap[k]) {
            inputs[keyMap[k]] = false;
            sendInput();
        }
    });
    
    // Mobile Support
    const btns = document.querySelectorAll('.control-btn');
    const mobMap = { 'btn-gas': 'up', 'btn-brake': 'down', 'btn-left': 'left', 'btn-right': 'right' };
    btns.forEach(btn => {
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); inputs[mobMap[btn.id]] = true; sendInput(); });
        btn.addEventListener('touchend', (e) => { e.preventDefault(); inputs[mobMap[btn.id]] = false; sendInput(); });
    });

    // --- CAMERA ---
    function updateCamera(targetCar) {
        const camDist = 14; const camHeight = 7;
        camera.position.x = targetCar.position.x - Math.sin(targetCar.rotation.y) * camDist;
        camera.position.z = targetCar.position.z - Math.cos(targetCar.rotation.y) * camDist;
        camera.position.y = camHeight;
        camera.lookAt(targetCar.position.x, targetCar.position.y + 1, targetCar.position.z);
    }

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    animate();

</script>
</body>
</html>
